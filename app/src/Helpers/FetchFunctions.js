import { Task } from "./TaskClass";

// Data base connection
const dataBase = {
    domain: "stasks.metalevel.tech",
    port: "48004",
    uri: "api/tasks",
    protocol: "https",
    get fqdn() {
        // const url = `${this.protocol}://${this.domain}/${this.uri}:${this.port}`;
        const url = `/${this.uri}`;
        return url;
    }
}

// We need this to store the task in the local state.
// The actual task id will be generated by the server, when we put it there.
function generateNewTaskId(tasks) {
    const lastId = tasks.reduce(
        (acc, task) => (task.data.id > acc) ? acc = task.data.id : acc, 0
    );

    return lastId + 1 + 1000000;
    // + 1000000 to make sure the id is always greater than the last one.
    // This is to avoid the situation, when the server generates the same id
    // for the object cleated as 'second' but saved as 'first'....
}

// AnimationApi effects
// const effectFadeIn = {
//     animation: [
//         { opacity: 0, filter: 'grayscale(1) hue-rotate(45deg)' },
//         { opacity: 1, filter: 'grayscale(0) hue-rotate(0)' }
//     ],
//     params: {
//         delay: 200,
//         duration: 500,
//         iterations: 1,
//         easing: 'ease-in'
//     }
// };

// GET all tasks from DataBase
async function getTasksListFromDataBase(tasks = []) {
    const request = {
        url: `${dataBase.fqdn}`,
        init: { method: "GET" }
    };

    return fetch(request.url, request.init)
        .then(response => {
            if (response.ok) return response.json();
            throw new Error(`Network response was not ok: ${response.status}`);
        })
        .then(data => {
            data.forEach(taskData => {
                const task = new Task(taskData);

                task.state.isNewTask = false;
                task.state.isLocked = true;
                task.state.toSave = false;

                tasks.push(task);
            });

            return tasks;
        })
        .catch(error => { console.log(`Trouble at tasks list get: ${error}`); });
}

// DELETE existing task
async function removeSingleTaskFromDataBase(task) {
    const request = {
        url: `${dataBase.fqdn}/${task.data.id}`,
        init: { method: "DELETE" }
    };

    return fetch(request.url, request.init)
        .then(response => {
            if (response.ok) return response.json();
            throw new Error(`${response.status} This task doesn't exist in the DataBase.`);
        })
        .catch(error => { console.log(`Trouble at task delete: ${error}`); });
}


// POST new task, PUT existing task
async function saveSingleTaskToDataBase(task) {
    const request = {
        url: `${dataBase.fqdn}`,
        init: { headers: { "Content-Type": "application/json" } }
    };

    if (task.state.isNewTask) {
        delete task.data.id; // Let the DataBase generate the Id.
        request.init.method = "POST";
        request.init.body = JSON.stringify(task.data);
    } else {
        request.url += `/${task.data.id}` // Add the Id to the URL.
        request.init.method = "PUT";
        request.init.body = JSON.stringify(task.data);
    }

    const updatedTask = { ...task };

    return fetch(request.url, request.init)
        .then(response => {
            if (response.ok) return response.json();
            throw new Error(`Network response was not ok: ${response.status}`);
        })
        .then(data => {
            // This is temporal value to display, because we don't send the task 
            // back to the server, but we update the task in the state.
            // Normally we want the user to see the the placeholder message
            // and enter its own title. Probably we should dismiss tasks without title.
            data.title = data.title ? data.title : `id: ${data.id}`;

            updatedTask.data = data;
            updatedTask.state.toRemove = false;
            updatedTask.state.toSave = false;
            updatedTask.state.isNewTask = false;

            return updatedTask;
        })
        .catch(error => { console.log(`Trouble at task save: ${error}`); });
}

// GET single task from DataBase
async function getSingleTaskFromDataBase(task) {
    const request = {
        url: `${dataBase.fqdn}/${task.data.id}`,
        init: { method: "GET" }
    };

    return fetch(request.url, request.init)
        .then(response => {
            if (response.ok) return response.json();
            throw new Error(`Network response was not ok: ${response.status}`);
        })
        .then(data => {
            const taskData = data;
            return taskData;
        })
        .catch(error => { console.log(`Trouble at task get: ${error}`); });
}


export {
    generateNewTaskId as newTaskId,
    getTasksListFromDataBase as getTasksListDB,
    removeSingleTaskFromDataBase as removeTaskDB,
    saveSingleTaskToDataBase as saveTaskDB,
    getSingleTaskFromDataBase as getTaskDB
};